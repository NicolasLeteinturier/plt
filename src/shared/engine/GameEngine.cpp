#include <queue>

///////////////////////////////////////////////////////////////////////////////////////////////////

// Generated by dia2code
#ifndef ENGINE__GAMEENGINE__H
#define ENGINE__GAMEENGINE__H

#include <memory>

namespace state {
  class GameState;
};
namespace engine {
  class Command;
}

#include "../state/GameState.h"
#include "Command.h"

namespace engine {

  /// class GameEngine - 
  class GameEngine {
    // Associations
    // Attributes
  public:
    std::shared_ptr<state::GameState> gameState;
    std::queue<std::shared_ptr<Command>> commands;
    // Operations
  public:
    GameEngine ();
    void ExecuteCommands ();
  private:
    void ExecuteAttackCommand ();
    void ExecuteMovementCommand ();
    void ExecuteReinforcementCommand ();
    void ExecuteInitialisationCommand ();
    int GetCountryClicked (int mousePositionX, int mousePositionY);
    // Setters and Getters
  };

};

#endif
/////////////////////////////////////////////////////////////////////////////////////////////////

#include "../../define.h"
#include <iostream>
#include <SFML/Graphics.hpp>
#include "../state/Movement.h"
#include "../state/Attack.h"
#include "../state/Initialisation.h"
#include "../state/Reinforcements.h"
#include <algorithm>
#include <string>

unsigned int etat = 0;

using namespace engine;
using namespace state;

GameEngine::GameEngine()
{

}

void GameEngine::ExecuteCommands()
{
	if(commands.empty())
	{
		return;
	}

	unsigned int n = commands.size();

	for(unsigned int i = 0; i < n; i++)
	{
		if(gameState->currentAction->GetActionType() == ActionType::_INITIALISATION)
		{
			ExecuteInitialisationCommand();
			commands.pop();
		}

		else if(gameState->currentAction->GetActionType() == ActionType::_REINFORCEMENTS)
		{
			ExecuteReinforcementCommand();
			commands.pop();
		}

		else if(gameState->currentAction->GetActionType() == ActionType::_ATTACK)
		{
			ExecuteAttackCommand();
			commands.pop();
		}

		else if(gameState->currentAction->GetActionType() == ActionType::_MOVEMENT)
		{
			ExecuteMovementCommand();
			commands.pop();
		}
	}

	return;
}

void GameEngine::ExecuteAttackCommand()
{
	std::shared_ptr<Command> command = commands.front();

	if(command->pressedKey == KeyPressed::ESCAPE)
	{
		gameState->GoToNextAction();
		etat = 0;
	}

	// etat vaut 0 : selection du pays attaquant
	if(etat == 0 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		int country_index = GetCountryClicked(command->mousePositionX,command->mousePositionY);
		if(country_index == -1){return;}
		std::shared_ptr<Country> selected_country = gameState->listCountry[country_index];
		if(selected_country->owner != gameState->currentPlayer)
		{
			printf("Ce pays ne vous appartient pas\n");
			return;
		}
		std::shared_ptr<Attack> attack = std::dynamic_pointer_cast<Attack>(gameState->currentAction);
		attack->attackerCountry = selected_country;
		etat = 1;
		return;
	}

	// etat vaut 1 : selection du pays à attaquer
	if(etat == 1 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		int country_index = GetCountryClicked(command->mousePositionX,command->mousePositionY);
		if(country_index == -1){return;}
		std::shared_ptr<Country> selected_country = gameState->listCountry[country_index];
		if(selected_country->owner == gameState->currentPlayer)
		{
			printf("Vous ne pouvez pas vous attaquer vous même !!!\n");
			return;
		}
		std::shared_ptr<Attack> attack = std::dynamic_pointer_cast<Attack>(gameState->currentAction);


		// On verifie que le pays selectionné est bien voisin du pays de l'attaquant
		for(unsigned int i = 0; i < attack->attackerCountry->neighboor.size(); i++)
		{
			if(attack->attackerCountry->neighboor[i] == selected_country)
			{
				attack->defencerCountry = selected_country;
				attack->unitSelected = true;
				etat = 2;
				return;
			}
		}

		printf("Ce pays n'est pas voisin du vôtre\n");
	}

	// etat vaut 2 : l'attaquant selectionne les unités avec lesquelles il souhaite attaquer
	if(etat == 2 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		std::shared_ptr<Attack> attack = std::dynamic_pointer_cast<Attack>(gameState->currentAction);

		if(command->mousePositionX <= 405 && command->mousePositionX >= 245)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				// Si il ne reste qu'une unité dans le pays attaquant on ne l'ajoute pas aux unités attaquantes
				if(attack->attackerCountry->listUnit.size() <= 1)
				{
					printf("Vous ne pouvez pas vider entièrement vôtre pays\n");
					return;
				}

				for(unsigned int i = 0; i < attack->attackerCountry->listUnit.size(); i++)
				{
					if(attack->attackerCountry->listUnit[i]->type == Type::defensif)
					{
						attack->AddUnit(attack->attackerCountry->listUnit[i]);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < attack->attackerUnits.size(); i++)
				{
					if(attack->attackerUnits[i]->type == Type::defensif)
					{
						attack->attackerCountry->AddUnit(attack->attackerUnits[i]);
						attack->attackerUnits.erase(attack->attackerUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}

		else if(command->mousePositionX <= 680 && command->mousePositionX >= 520)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				// Si il ne reste qu'une unité dans le pays attaquant on ne l'ajoute pas aux unités attaquantes
				if(attack->attackerCountry->listUnit.size() <= 1)
				{
					printf("Vous ne pouvez pas vider entièrement vôtre pays\n");
					return;
				}

				for(unsigned int i = 0; i < attack->attackerCountry->listUnit.size(); i++)
				{

					if(attack->attackerCountry->listUnit[i]->type == Type::neutre)
					{
						attack->AddUnit(attack->attackerCountry->listUnit[i]);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < attack->attackerUnits.size(); i++)
				{
					if(attack->attackerUnits[i]->type == Type::neutre)
					{
						attack->attackerCountry->AddUnit(attack->attackerUnits[i]);
						attack->attackerUnits.erase(attack->attackerUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}

		else if(command->mousePositionX <= 930 && command->mousePositionX >= 770)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				// Si il ne reste qu'une unité dans le pays attaquant on ne l'ajoute pas aux unités attaquantes
				if(attack->attackerCountry->listUnit.size() <= 1)
				{
					printf("Vous ne pouvez pas vider entièrement vôtre pays\n");
					return;
				}

				for(unsigned int i = 0; i < attack->attackerCountry->listUnit.size(); i++)
				{
					if(attack->attackerCountry->listUnit[i]->type == Type::attaquant)
					{
						attack->AddUnit(attack->attackerCountry->listUnit[i]);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < attack->attackerUnits.size(); i++)
				{
					if(attack->attackerUnits[i]->type == Type::attaquant)
					{
						attack->attackerCountry->AddUnit(attack->attackerUnits[i]);
						attack->attackerUnits.erase(attack->attackerUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}
	}

	// Si le joueur presse la touche entrée on passe à l'état suivant et on ajoute les unités du pays defenseur aux unités défensives
	if(etat == 2 && command->pressedKey == KeyPressed::ENTER)
	{
		std::shared_ptr<Attack> attack = std::dynamic_pointer_cast<Attack>(gameState->currentAction);
		attack->unitSelected = false;

		unsigned int n = attack->defencerCountry->listUnit.size();
		std::cout << "nombre d'unité pays attaqué = " << std::to_string(attack->defencerCountry->listUnit.size()) << std::endl;

		for(unsigned int i = 0; i < n; i++)
		{
			attack->AddUnit(attack->defencerCountry->listUnit[0]);
			std::cout << "ajout d'une nouvelle unité à l'attaque" << std::endl;
		}
		attack->displayAttack = true;
		etat = 3;
	}

	// etat vaut 3 : on lance l'attaque ...
	if(etat == 3 && command->pressedKey == KeyPressed::SPACE_BARRE)
	{
		std::shared_ptr<Attack> attack = std::dynamic_pointer_cast<Attack>(gameState->currentAction);

		if(attack->attackerUnits.size() == 0)
		{
			etat = 0;
			attack->displayAttack = false;
			attack->AttackIsOver();
			gameState->GoToNextAction();
			return;
		}

		if(attack->defencerUnits.size() == 0)
		{
			etat = 0;
			attack->displayAttack = false;
			attack->AttackIsOver();
			gameState->ChangeCountryOwner(attack->defencerCountry, attack->attackerCountry->owner);
			gameState->GoToNextAction();
			return;
		}

		srand (time(NULL));

		/*if(attack->attackerUnits.size() >= 2)
		{
			int attacker_de_1 = rand()%6;
			if(attack->attackerUnits[0]->type == Type::attaquant){attacker_de_1++;}
			if(attack->attackerUnits[0]->type == Type::defensif){attacker_de_1--;}

			int attacker_de_2 = rand()%6;
			if(attack->attackerUnits[1]->type == Type::attaquant){attacker_de_1++;}
			if(attack->attackerUnits[1]->type == Type::defensif){attacker_de_1--;}

			int attacker_max = std::max(attacker_de_1,attacker_de_2);
			int attacker_min = std::min(std::min(attacker_de_1,attacker_de_2),attacker_de_3);
			
			if(attack->defencerUnits.size() >= 2) 
			{
				int defencer_de_1 = rand()%6;
				if(attack->defencerUnits[0]->type == Type::attaquant){attacker_de_1--;}
				if(attack->defencerUnits[0]->type == Type::defensif){attacker_de_1++;}

				int defencer_de_2 = rand()%6;
				if(attack->defencerUnits[1]->type == Type::attaquant){attacker_de_1--;}
				if(attack->defencerUnits[1]->type == Type::defensif){attacker_de_1++;}

				int defencer_max = std::max(defencer_de_1,defencer_de_2);
				int defencer_min = std::min(defencer_de_1,defencer_de_2);

				// Comparaison entre les dés
				if(attacker_max >= defencer_max && attacker_min >= defencer_min)
				{
					attack->KillUnit(attack->defencerUnit[0]);
					attack->KillUnit(attack->defencerUnit[0]);	
				}

				if(attacker_max >= defencer_max && attacker_min <= defencer_min)
				{
					attack->KillUnit(attack->defencerUnit[0]);
					attack->KillUnit(attack->attackerUnit[1]);
				}

				if(attacker_max <= defencer_max && attacker_min >= defencer_min)
				{
					attack->KillUnit(attack->attackerUnit[0]);
					attack->KillUnit(attack->defencerUnit[1]);	
				}

				if(attacker_max <= defencer_max && attacker_min <= defencer_min)
				{
					attack->KillUnit(attack->attackerUnit[0]);
					attack->KillUnit(attack->attackerUnit[0]);
				}
			}

			if(attack->defencerUnits.size() == 1) 
			{
				int defencer_de = rand()%6;
				if(attack->defencerUnits[0]->type == Type::attaquant){attacker_de_1--;}
				if(attack->defencerUnits[0]->type == Type::defensif){attacker_de_1++;}

				// Comparaison entre les dés
				if(attacker_max >= defencer_de){attack->KillUnit(attack->defencerUnit[0]);}
				else
				{
					attack->KillUnit(attack->attackerUnit[0]);
					attack->KillUnit(attack->attackerUnit[0]);
				}
			}
		}

		else
		{
			int attacker_de = rand()%6;
			if(attack->attackerUnits[0]->type == Type::attaquant){attacker_de_1++;}
			if(attack->attackerUnits[0]->type == Type::defensif){attacker_de_1--;}

			if(attack->defencerUnits.size() >= 2) 
			{
				int defencer_de_1 = rand()%6;
				if(attack->defencerUnits[0]->type == Type::attaquant){attacker_de_1--;}
				if(attack->defencerUnits[0]->type == Type::defensif){attacker_de_1++;}

				int defencer_de_2 = rand()%6;
				if(attack->defencerUnits[1]->type == Type::attaquant){attacker_de_1--;}
				if(attack->defencerUnits[1]->type == Type::defensif){attacker_de_1++;}

				int defencer_max = std::max(defencer_de_1,defencer_de_2);
				int defencer_min = std::min(defencer_de_1,defencer_de_2);

				// Comparaison entre les dés

				if(defencer_max >= attacker_de){attack->KillUnit(attack->attackerUnit[0]);}
				else
				{
					attack->KillUnit(attack->defencerUnit[0]);
					attack->KillUnit(attack->defencerUnit[0]);
				}

			}
			else
			{
				int defencer_de = rand()%6;
				if(attack->defencerUnits[0]->type == Type::attaquant){attacker_de_1--;}
				if(attack->defencerUnits[0]->type == Type::defensif){attacker_de_1++;}

				//Comparaison entre les dés

			}
			
		}*/

		int attacker_de;
		int defencer_de;

		if(attack->attackerUnits[0]->type == Type::attaquant){attacker_de = rand()%8;}
		else if(attack->attackerUnits[0]->type == Type::defensif){attacker_de = rand()%4;}
		else if(attack->attackerUnits[0]->type == Type::neutre){attacker_de = rand()%6;}
		if(attack->defencerUnits[0]->type == Type::attaquant){defencer_de = rand()%4;}
		else if(attack->defencerUnits[0]->type == Type::defensif){defencer_de = rand()%8;}
		else if(attack->defencerUnits[0]->type == Type::neutre){defencer_de = rand()%6;}

		if(attacker_de > defencer_de){attack->KillUnit(attack->defencerUnits[0]);}
		else if(attacker_de < defencer_de){attack->KillUnit(attack->attackerUnits[0]);}

		std::cout << "score aux dés de l'attaquant = " << std::to_string(attacker_de) << std::endl;
		std::cout << "score aux dés du defenceur = " << std::to_string(defencer_de) << std::endl;

		std::cout << "nombre d'unité de l'attaquant = " << std::to_string((attack->attackerUnits.size())) << std::endl;
		std::cout << "nombre d'unité du defenseur = " << std::to_string((attack->defencerUnits.size())) << std::endl;

	}

	return;

}


void GameEngine::ExecuteMovementCommand()
{
	std::shared_ptr<Command> command = commands.front();

	if(command->pressedKey == KeyPressed::ESCAPE)
	{
		gameState->GoToNextAction();
		etat = 0;
	}

	// etat vaut 0 : selection du pays d'origine
	if(etat == 0 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		int country_index = GetCountryClicked(command->mousePositionX,command->mousePositionY);
		if(country_index == -1){return;}
		std::shared_ptr<Country> selected_country = gameState->listCountry[country_index];
		if(selected_country->owner != gameState->currentPlayer)
		{
			printf("ce pays ne vous appartient pas\n");
			return;
		}
		std::shared_ptr<Movement> movement = std::dynamic_pointer_cast<Movement>(gameState->currentAction);
		movement->origin = selected_country;
		etat = 1;
		return;
	}

	// etat vaut 1 : selection du pays de destination

	if(etat == 1 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		int country_index = GetCountryClicked(command->mousePositionX,command->mousePositionY);
		if(country_index == -1){return;}
		std::shared_ptr<Country> selected_country = gameState->listCountry[country_index];
		if(selected_country->owner != gameState->currentPlayer)
		{
			printf("ce pays ne vous appartient pas\n");
			return;
		}
		std::shared_ptr<Movement> movement = std::dynamic_pointer_cast<Movement>(gameState->currentAction);
		movement->destination = selected_country;
		movement->unitSelected = true;
		etat = 2;
		return;
	}

	// etat vaut 2 : selection des unités à deplacer

	if(etat == 2 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		std::shared_ptr<Movement> movement = std::dynamic_pointer_cast<Movement>(gameState->currentAction);

		if(command->mousePositionX <= 405 && command->mousePositionX >= 245)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				// Si il ne reste qu'une unité dans le pays d'origine on ne peut plus deplacer d'unité
				if(movement->origin->listUnit.size() <= 1)
				{
					printf("Vous ne pouvez pas vider entièrement vôtre pays\n");
					return;
				}

				for(unsigned int i = 0; i < movement->origin->listUnit.size(); i++)
				{
					if(movement->origin->listUnit[i]->type == Type::defensif)
					{
						movement->AddUnitToMove(movement->origin->listUnit[i]);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < movement->units.size(); i++)
				{
					if(movement->units[i]->type == Type::defensif)
					{
						movement->origin->AddUnit(movement->units[i]);
						movement->units.erase(movement->units.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}

		else if(command->mousePositionX <= 680 && command->mousePositionX >= 520)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				// Si il ne reste qu'une unité dans le pays d'origine on ne peut plus deplacer d'unité
				if(movement->origin->listUnit.size() <= 1)
				{
					printf("Vous ne pouvez pas vider entièrement vôtre pays\n");
					return;
				}

				for(unsigned int i = 0; i < movement->origin->listUnit.size(); i++)
				{
					if(movement->origin->listUnit[i]->type == Type::neutre)
					{
						movement->AddUnitToMove(movement->origin->listUnit[i]);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < movement->units.size(); i++)
				{
					if(movement->units[i]->type == Type::neutre)
					{
						movement->origin->AddUnit(movement->units[i]);
						movement->units.erase(movement->units.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}

		else if(command->mousePositionX <= 930 && command->mousePositionX >= 770)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				// Si il ne reste qu'une unité dans le pays d'origine on ne peut plus deplacer d'unité
				if(movement->origin->listUnit.size() <= 1)
				{
					printf("Vous ne pouvez pas vider entièrement vôtre pays\n");
					return;
				}

				for(unsigned int i = 0; i < movement->origin->listUnit.size(); i++)
				{
					if(movement->origin->listUnit[i]->type == Type::attaquant)
					{
						movement->AddUnitToMove(movement->origin->listUnit[i]);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < movement->units.size(); i++)
				{
					if(movement->units[i]->type == Type::attaquant)
					{
						movement->origin->AddUnit(movement->units[i]);
						movement->units.erase(movement->units.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}

	}

	// touche entrée appuyer : deplacement des unités sélectionnés et fin du tour

	if(etat == 2 && command->pressedKey == KeyPressed::ENTER)
	{
		std::shared_ptr<Movement> movement = std::dynamic_pointer_cast<Movement>(gameState->currentAction);
		movement->unitSelected = false;
		movement->MoveAllUnit();
		gameState->GoToNextAction();
		etat = 0;
	}
}


void GameEngine::ExecuteReinforcementCommand()
{
	std::shared_ptr<Command> command = commands.front();

	std::shared_ptr<Reinforcements> reinforcement = std::dynamic_pointer_cast<Reinforcements>(gameState->currentAction);
	static std::shared_ptr<Country> selected_country = std::make_shared<Country>();
	
	if((reinforcement->availableUnits.size() == 0 && reinforcement->selectedUnits.size() == 0) || command->pressedKey == KeyPressed::SPACE_BARRE)
	{
		reinforcement->unitSelected = false;
		gameState->GoToNextAction();
		etat = 0;
	}

	if(etat == 0 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		int country_index = GetCountryClicked(command->mousePositionX,command->mousePositionY);
		if(country_index == -1){return;}
		selected_country = gameState->listCountry[country_index];
		if(selected_country->owner != gameState->currentPlayer)
		{
			printf("ce pays ne vous appartient pas");
			return;
		}
		reinforcement->unitSelected = true;
		etat = 1;
		return;
	}

	if(etat == 1 && command->pressedKey == KeyPressed::LEFT_CLICK)
	{
		if(command->mousePositionX <= 405 && command->mousePositionX >= 245)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				for(unsigned int i = 0; i < reinforcement->availableUnits.size(); i++)
				{
					if(reinforcement->availableUnits[i]->type == Type::defensif)
					{
						reinforcement->selectedUnits.push_back(reinforcement->availableUnits[i]);
						reinforcement->availableUnits.erase(reinforcement->availableUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < reinforcement->selectedUnits.size(); i++)
				{
					if(reinforcement->selectedUnits[i]->type == Type::defensif)
					{
						reinforcement->availableUnits.push_back(reinforcement->availableUnits[i]);
						reinforcement->selectedUnits.erase(reinforcement->selectedUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}

		else if(command->mousePositionX <= 680 && command->mousePositionX >= 520)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				for(unsigned int i = 0; i < reinforcement->availableUnits.size(); i++)
				{
					if(reinforcement->availableUnits[i]->type == Type::neutre)
					{
						reinforcement->selectedUnits.push_back(reinforcement->availableUnits[i]);
						reinforcement->availableUnits.erase(reinforcement->availableUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < reinforcement->availableUnits.size(); i++)
				{
					if(reinforcement->selectedUnits[i]->type == Type::neutre)
					{
						reinforcement->availableUnits.push_back(reinforcement->availableUnits[i]);
						reinforcement->selectedUnits.erase(reinforcement->selectedUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}

		else if(command->mousePositionX <= 930 && command->mousePositionX >= 770)
		{
			if(command->mousePositionY <= 190 && command->mousePositionY >= 90)
			{
				for(unsigned int i = 0; i < reinforcement->availableUnits.size(); i++)
				{
					if(reinforcement->availableUnits[i]->type == Type::attaquant)
					{
						reinforcement->selectedUnits.push_back(reinforcement->availableUnits[i]);
						reinforcement->availableUnits.erase(reinforcement->availableUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else if(command->mousePositionY <= 500 && command->mousePositionY >= 400)
			{
				for(unsigned int i = 0; i < reinforcement->availableUnits.size(); i++)
				{
					if(reinforcement->selectedUnits[i]->type == Type::attaquant)
					{
						reinforcement->availableUnits.push_back(reinforcement->availableUnits[i]);
						reinforcement->selectedUnits.erase(reinforcement->selectedUnits.begin() + i);
						break;
					}
				}
				return;
			}

			else {return;}
		}
	}

	if(etat == 1 && command->pressedKey == KeyPressed::ENTER)
	{	
		unsigned int n = reinforcement->selectedUnits.size();
		for(unsigned int i = 0; i < n; i++)
		{
			reinforcement->PlaceUnit(reinforcement->selectedUnits[0],selected_country);
		}
		reinforcement->unitSelected = false;
		etat = 0;
	}

}


void GameEngine::ExecuteInitialisationCommand()
{
	std::shared_ptr<Command> command = commands.front();
	gameState->GoToNextAction();
}


int GameEngine::GetCountryClicked(int mousePositionX, int mousePositionY)
{
	sf::Image image;
	char table[NB_COUNTRY][40] = {COUNTRY_SPRITE_RESSOURCES};
	char country_name[NB_COUNTRY][40] = {COUNTRY_NAME};
	for (int i = 0; i < NB_COUNTRY; i++) { 
		if (!(image.loadFromFile(table[i])))
          		printf("Cannot load image");
		if(image.getPixel(mousePositionX,mousePositionY) != sf::Color::Transparent)
		{
			std::cout << country_name[i] << std::endl;
			return(i);
		}
	}
	return(-1);
}






